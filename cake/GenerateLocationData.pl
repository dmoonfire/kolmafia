#!/usr/bin/perl

#
# GenerateLocationData.pl 0.0.0
#

=pod
=head1 Introduction

This program combines data from various sources and builds pre-calculated maps
for the various Cake ASH libraries and functions. It uses data gathered from
KoLmafia's data files, the web, and also manually entered.

=head1 Data Formats
All of the map data generated by this script is tab-separated values with a
newline at the end.

=head2 Locations (cake_locations.txt)
=over

=item Location Name
Contains the name of the location, which is used as a string match.

=item Combat Rate
The rate of combat in the location. This is an integer between 0 and 100.

=item Location Type
A string in lowercase with underscores that identifies the type of location.
This is used to categorize the areas on function areas, such as locations used
for the island war (which we assume someone will use the Wossname.ash script)
or clan basements (which may not want automated processing).

=head1 Assumptions
=over

=item *
The MfGames SVN is set up with svn:externals to also download KoLmafia data into
 the 'kolmafia-data' directory. This script uses data from this directory.

=back

=cut

#
# Setup
#

# Directives
use strict;
use warnings;

# Variables
my %cake_locations = ();
my $cake_locations_file = "../data/cake_locations_000.txt";
my %cake_monsters = ();
my $cake_monsters_file = "../data/cake_monsters_000.txt";

my $kolmafia_combats_file = "../kolmafia-data/combats.txt";
my $kolmafia_monsters_file = "../kolmafia-data/monsters.txt";
my $kolmafia_noncombats_file = "../data/noncombats.txt";
my $kolmafia_events_file = "../data/events.txt";

my %kolmafia_events = ();

#
# Constants
#

# Monster record constants
use constant {
	MONSTER_HP => 0,
	MONSTER_DEFENSE => 1,
	MONSTER_ELEMENT_DEFENSE => 2,
	MONSTER_ATTACK => 3,
	MONSTER_ELEMENT_ATTACK => 4,
	MONSTER_ELEMENT => 5,
	MONSTER_MEAT => 6,
	MONSTER_STAT => 7,
	MONSTER_EFFECT => 8,

	MONSTER_COLUMNS => 10,
};

use constant {
	LOCATION_COMBAT_RATE => 0,
	LOCATION_TYPE => 1,
	LOCATION_MAXIMIZE_HINT => 2,
	LOCATION_COMBAT_MEAT => 3, 
	LOCATION_COMBAT_STATS => 4,
	LOCATION_AVG_HP => 5, 
	LOCATION_MAX_HP => 6, 
	LOCATION_AVG_DEFENSE => 7, 
	LOCATION_MAX_DEFENSE => 8, 
	LOCATION_AVG_ATTACK => 9, 
	LOCATION_MAX_ATTACK => 10,
	LOCATION_NONCOMBAT_MUS => 11,
	LOCATION_NONCOMBAT_MOX => 12,
	LOCATION_NONCOMBAT_MYS => 13,
	LOCATION_NONCOMBAT_MEAT => 14,
	LOCATION_CLOVER_MUS => 15,
	LOCATION_CLOVER_MOX => 16,
	LOCATION_CLOVER_MYS => 17,
	LOCATION_CLOVER_MEAT => 18,

	LOCATION_COLUMNS => 20,
};

#
# Start by loading the prior cake_locations.txt into memory. This is keyed by
# the location in the first column and has the template that we will be
# populating with other data. This is intended to allow the program to
# repeatedly be run into the file, editing it in place, and then checked into
# the repository so KoLmafia can download the latest and greatest version
# (also because I'm lazy about updating files and this is scriptable).
#

info(0, "Reading in cake_locations.txt");
my $cake_locations_fields = 0;
open INPUT, "<$cake_locations_file"
	or die "Cannot open $cake_locations_file ($!)";
my $cake_locations_header = <INPUT>;

while (<INPUT>)
{
	# Clean up the line and ignores comments and blanks.
	chomp;
	next if /^\#/;
	next if /^\s*$/;

	# When editing the file with OpenOffice.org or Excel, those programs
	# insist on putting double quotes in the file. These don't naturally
	# occur so strip them out.
	s/"//g;

	# Split the line by the tab characters
	my @parts = split(/\t/);

	if (@parts != LOCATION_COLUMNS)
	{
		error(1, "Line $. has "
			. scalar(@parts) . " instead of " . LOCATION_COLUMNS
			. " expected columns.");
		error(1, $_);
	}

	my $location_name = shift @parts;
	$cake_locations{$location_name} = \@parts;
}

info(1, "Found " . scalar(keys %cake_locations) . " locations.");
close INPUT;

#
# Load in KoLmafia's monsters.txt file to get information on the possible
# encounters that a player can find. This includes data on base hit points,
# attack levels, and defenses. It also includes item drop information.#
#

# Read in the combat data. Ignore the first row, it is a version field or
# something to that effect.
info(0, "Reading KoLmafia's monster data...");
open INPUT, "<$kolmafia_monsters_file"
	or die "Cannot read $kolmafia_monsters_file ($!)";
<INPUT>;

while (<INPUT>)
{
	# Clean up the line
	chomp;
	next if /^\#/;
	next if /^\s*$/;

	# Split the line on the tab characters and pull out the constant fields.
	my @parts = split(/\t/);
	next if @parts < 2;
	my $monster_name = shift @parts;
	my $stats = shift @parts;

	# Process the stats block. If this is blank, then we have a scaling
	# monsters and this currently ignores that. Otherwise, it contains
	# data in the format "HP: \d+ Def: \d+ Atk: \d". Optionally, it will
	# include "E: element" to indicate an elemental creature.
	next if $stats =~ m/^\s*$/;

	my $orig_stats = $stats;
	my $hp = 0;
	my $attack = 0;
	my $defense = 0;
	my $element = "";
	my $element_attack = "";
	my $element_defense = "";
	my $meat = 0;
	my $effect = "";
	my $stat = 0;

	$effect = $1 if $stats =~ s@\"([\w\s]+)\"@@;
	$hp = $1 if $stats =~ s@HP: (\d+)@@;
	$attack = $1 if $stats =~ s@Atk: (\d+)@@;
	$defense = $1 if $stats =~ s@Def: (\d+)@@;
	$element = $1 if $stats =~ s@E: (\w+)@@;
	$element_attack = $1 if $stats =~ s@EA: (\w+)@@;
	$element_attack .= ", $1" if $stats =~ s@EA: (\w+)@@;
	$element_defense = $1 if $stats =~ s@ED: (\w+)@@;
	$meat = $1 if $stats =~ s@Meat: ([\d-]+)@@;

	error(1, "$monster_name stats has extras: $orig_stats -> $stats")
		unless ($stats =~ m/^\s*$/);

	# Normalize the values, such as averaging out the meat expected and
	# filling in some blanks (by guessing).
	$meat = ($1 + $2) / 2 if $meat =~ /^(\d+)-(\d+)/;

	# These values come from http://kol.coldfront.net/thekolwiki/index.php/Monster_Level
	$defense = $attack if $defense == 0;
	$hp = int($attack * 0.8) if $hp == 0;
	$stat = $attack / 4 if $stat == 0;

	# Process the item drops since we calculate the potential meat value
	# of these items.
#	my @items = ();

#	foreach my $encounter (@parts)
#	{
#		if ($encounter =~ m@^(.*?): (-?\d+)@)
#		{
#			# If we have a weight of 0 or -1, then ignore it.
#			next if $2 <= 0;
#		}

#		push @encounters, $encounter;
#	}

#	$kolmafia_combat_encounters{$location_name} = \@encounters
#		if @encounters > 0;

	# Save the information in a hash.
	my @array = ($hp, $defense, $element_defense, $attack, $element_attack,
		$element, $meat, $stat, $effect);
	$cake_monsters{$monster_name} = \@array;
}

info(1, "Read in " . scalar(keys %cake_monsters) . " records.");
close INPUT;

#
# Load in events.txt file.
#

# Read in the events data.
info(0, "Reading events data...");
open INPUT, "<$kolmafia_events_file"
	or die "Cannot read $kolmafia_events_file ($!)";
<INPUT>;

while (<INPUT>)
{
	# Clean up the line
	chomp;
	next if /^\#/;
	next if /^\s*$/;

	# Split the line on the tab characters and pull out the constant fields.
	my @parts = split(/\t/);
	next if @parts < 2;
	my $event_name = shift @parts;
	$kolmafia_events{$event_name} = \@parts;
}

info(1, "Read in " . scalar(keys %kolmafia_events) . " records.");
close INPUT;

#
# Load in the KoLmafia combats.txt file. This contains the name of the location,
# the combat rate, and also all the encounters within the location. Creatures
# can be modified a weight which adjusts the XP average. If the weight is zero,
# it is a special encounter so it isn't included.
#

# Read in the combat data. Ignore the first row, it is a version field or
# something to that effect.
info(0, "Reading KoLmafia's combat data...");
my $kolmafia_combats_count = 0;
open INPUT, "<$kolmafia_combats_file"
	or die "Cannot read $kolmafia_combats_file ($!)";
<INPUT>;

while (<INPUT>)
{
	# Clean up the line
	chomp;
	next if /^\#/;
	next if /^\s*$/;
	$kolmafia_combats_count++;

	# Split the line on the tab characters and pull out the constant fields.
	my @parts = split(/\t/);
	my $location_name = shift @parts;
	my $combat_rate = shift @parts;
	$combat_rate = 0 if $combat_rate < 0;

	# Go through the combats in the location.
	my $average_stats = 0;
	my $average_meat = 0;
	my $average_hp = 0;
	my $average_attack = 0;
	my $average_defense = 0;
	my $max_attack = 0;
	my $max_hp = 0;
	my $max_defense = 0;

	if (@parts)
	{
		my $monster_count = 0;
		my $stats_total = 0;
		my $meat_total = 0;
		my $attack_total = 0;
		my $defense_total = 0;
		my $hp_total = 0;

		info(1, "Encounters for $location_name");
		foreach my $monster (@parts)
		{
			# Strip out specials and boss fights. We strip out the
			# even ascension only encounters because they should
			# average out (Hole in the Sky).
			next if $monster =~ /: e/;
			my $weight = 1;
			if ($monster =~ m@^(.*?): [eo]?(-?\d+)@)
			{
				# Set it so the encounter has the name with a weight.
				$weight = $2;
				$monster = $1;

				# If we have a weight of 0 or -1, then ignore it.
				next if $weight <= 0;
			}

			# See if we can find the encounter in our data.
			unless (exists $cake_monsters{$monster})
			{
				error(2, "Cannot find $monster in monsters data.");
				next;
			}

			my $monster_data = $cake_monsters{$monster};

			# Keep a running total of data in our calculations.
			$monster_count++;
			$stats_total += ($$monster_data[MONSTER_STAT] + 0) * $weight;
			$meat_total += ($$monster_data[MONSTER_MEAT] + 0) * $weight;
			$hp_total += ($$monster_data[MONSTER_HP] + 0) * $weight;
			$defense_total += ($$monster_data[MONSTER_DEFENSE] + 0) * $weight;
			$attack_total += ($$monster_data[MONSTER_ATTACK] + 0) * $weight;

			$max_hp = $$monster_data[MONSTER_HP]
				if $max_hp < $$monster_data[MONSTER_HP];
			$max_defense = $$monster_data[MONSTER_DEFENSE]
				if $max_defense < $$monster_data[MONSTER_DEFENSE];
			$max_attack = $$monster_data[MONSTER_ATTACK]
				if $max_attack < $$monster_data[MONSTER_ATTACK];

			info(2, "Encounter: $monster ($weight)");
		}

		# Calculate the averages
		if ($monster_count > 0)
		{
			$average_meat = $meat_total / $monster_count;
			$average_stats = $stats_total / $monster_count;
			$average_hp = $hp_total / $monster_count;
			$average_defense = $defense_total / $monster_count;
			$average_attack = $attack_total / $monster_count;
		}

		# Write out a summary of the results.
		info(2, "Combat Summary: count=$monster_count"
			. ", meat=$average_meat"
			. ", stat gain=$average_stats"
			. ", hp=$average_hp ($max_hp)"
			. ", defense=$average_defense ($max_defense)"
			. ", attack=$average_attack ($max_attack)");
	}

	# Get our location data for this location.
	my $location = get_location($location_name);
	$$location[LOCATION_COMBAT_RATE] = $combat_rate;
	$$location[LOCATION_COMBAT_MEAT] = $average_meat;
	$$location[LOCATION_COMBAT_STATS] = $average_stats;
	$$location[LOCATION_AVG_HP] = $average_hp;
	$$location[LOCATION_MAX_HP] = $max_hp;
	$$location[LOCATION_AVG_DEFENSE] = $average_defense;
	$$location[LOCATION_MAX_DEFENSE] = $max_defense;
	$$location[LOCATION_AVG_ATTACK] = $average_attack;
	$$location[LOCATION_MAX_ATTACK] = $max_attack;
}

info(1, "Read in $kolmafia_combats_count records.");
close INPUT;

#
# Load in the noncombats.txt file. This contains the name of the location and
# the various non-combat adventures for that location.
#

# Read in the noncombat data.
info(0, "Reading noncombat data...");
my $kolmafia_noncombats_count = 0;
open INPUT, "<$kolmafia_noncombats_file"
	or die "Cannot read $kolmafia_noncombats_file ($!)";

while (<INPUT>)
{
	# Clean up the line
	chomp;
	next if /^\#/;
	next if /^\s*$/;
	$kolmafia_noncombats_count++;

	# Split the line on the tab characters and pull out the constant fields.
	my @parts = split(/\t/);
	my $location_name = shift @parts;

	# Go through the noncombats in the location.
	my ($clover_mus, $clover_mox, $clover_mys, $clover_meat) = (0, 0, 0, 0);
	my $noncombat_mus = "";
	my $noncombat_mox = "";
	my $noncombat_mys = "";
	my $noncombat_meat = "";

	if (@parts)
	{
		info(1, "Events for $location_name");

		my $event_total_weight = 0;

		foreach my $event (@parts)
		{
			# Strip out the weight.
			my $weight = 1;
			$weight = $2 if $event =~ s/: (\w)(\d+)/: $1/;

			# Ignore conditionals, bad moons, one-times, semi-rares.
			next if $event =~ /: [bocs]/;

			# If this is a clover, put it in the clover fields.
			# Without the depressingly lame monster, of course.
			if ($event =~ s/: t//)
			{
				($clover_mus, $clover_mox, $clover_mys, $clover_meat) =
					parse_event($event);
				next;
			}

			# Add the event and weigh it for the event weighting
			# so we can attempt to come up with an "average" gain
			# for the noncombats.
			my ($mus, $mox, $mys, $meat) = parse_event($event);
			$noncombat_mus = build_average($noncombat_mus, $mus, $weight);
			$noncombat_mox = build_average($noncombat_mox, $mox, $weight);
			$noncombat_mys = build_average($noncombat_mys, $mys, $weight);
			$noncombat_meat = build_average($noncombat_meat, $meat, $weight);
			$event_total_weight += $weight;

			info(2, "Event: $event: mus=$mus, mox=$mox, mys=$mys, meat=$meat");
		}

		# If we have some weighing, then calculate it out. Since we have
		# a running total
		if ($event_total_weight > 0)
		{
			$noncombat_mus .= "$event_total_weight /" if $noncombat_mus ne "";
			$noncombat_mox .= "$event_total_weight /" if $noncombat_mox ne "";
			$noncombat_mys .= "$event_total_weight /" if $noncombat_mys ne "";
			$noncombat_meat .= "$event_total_weight /" if $noncombat_meat ne "";
		}
	}

	$noncombat_mus = 0 if $noncombat_mus eq "";
	$noncombat_mox = 0 if $noncombat_mox eq "";
	$noncombat_mys = 0 if $noncombat_mys eq "";
	$noncombat_meat = 0 if $noncombat_meat eq "";

	# Get our location data for this location.
	my $location = get_location($location_name);
	$$location[LOCATION_NONCOMBAT_MUS] = $noncombat_mus;
	$$location[LOCATION_NONCOMBAT_MOX] = $noncombat_mox;
	$$location[LOCATION_NONCOMBAT_MYS] = $noncombat_mys;
	$$location[LOCATION_NONCOMBAT_MEAT] = $noncombat_meat;
	$$location[LOCATION_CLOVER_MUS] = $clover_mus;
	$$location[LOCATION_CLOVER_MOX] = $clover_mox;
	$$location[LOCATION_CLOVER_MYS] = $clover_mys;
	$$location[LOCATION_CLOVER_MEAT] = $clover_meat;
}

info(1, "Read in $kolmafia_combats_count records.");
close INPUT;

#
# Write out the cake data into the same as the place we found it. This
# will now have all the altered data.
#

info(0, "Writing out modified location data...");
open OUTPUT, ">$cake_locations_file" or die "Cannot write $cake_locations_file ($!)";
print OUTPUT $cake_locations_header;

foreach my $key (sort keys %cake_locations)
{
	my $array_ref = $cake_locations{$key};
	my @array = @$array_ref;

	print OUTPUT "$key\t" . join("\t", @array) . "\n";
}

info(1, "Wrote out " . scalar(keys %cake_locations) . " locations.");
close OUTPUT;

info(0, "Writing out modified monster data...");
open OUTPUT, ">$cake_monsters_file" or die "Cannot write $cake_monsters_file ($!)";
print OUTPUT join("\t",
	"# Monster",
	"HP",
	"Defense",
	"ElementDefense",
	"Attack",
	"ElementDefense",
	"Element",
	"Meat",
	"Stat",
	"Effect");

foreach my $key (sort keys %cake_monsters)
{
	my $array_ref = $cake_monsters{$key};
	my @array = @$array_ref;

	print OUTPUT "$key\t" . join("\t", @array) . "\n";
}

info(1, "Wrote out " . scalar(keys %cake_monsters) . " monsters.");
close OUTPUT;

sub build_average
{
	my $buffer = shift @_;
	my $formula = shift @_;
	my $weight = shift @_;

	return $buffer if $formula eq "" || $formula eq "0";
	return "$formula $weight * " if ($buffer eq "");
	return "$buffer $formula $weight * + ";
}

#
# Parses an event and builds out the fields.
#

sub get_choice
{
	my $ref = shift @_;
	my $base_index = shift @_;
	my $index = $base_index * 5 + 2;
	return ($$ref[$index], $$ref[$index+1], $$ref[$index+2], $$ref[$index+3]);
}

sub parse_event
{
	# Get the event and make sure it exists.
	my $event_name = shift @_;

	unless (exists $kolmafia_events{$event_name})
	{
		return (0, 0, 0, 0);
	}

	# If there is only one choice, then we use that.
	my $ref = $kolmafia_events{$event_name};
	my $count = $$ref[1];

	if ($count == 1)
	{
		return ($$ref[2], $$ref[3], $$ref[4], $$ref[5]);
	}

	# Get the first one that actually has some data.
	info(2, "There are $count choices for this event.");

	for my $index (0...$count-1)
	{
		# Get the choice.
		my @choice = get_choice($ref, $index);
		next if join(":", @choice) eq "0:0:0:0";

		info(3, "Choice " . ($index + 1) . ": " . join(", ", @choice));
		return @choice;
	}

	# Couldn't find anything.
	return (0, 0, 0, 0);
}

#
# Retrieves the location data, automatically creating a record if it doesn't exist.
#

sub get_location
{
	# Grab the name and see if we already have it.
	my $location_name = shift @_;

	return $cake_locations{$location_name}
		if (exists $cake_locations{$location_name});

	# It doesn't exist, so create a new one.
	info(1, "Creating location: $location_name");

	my @parts = qw/100 none/;
	$cake_locations{$location_name} = \@parts;
	return \@parts;
}

#
# Simplified functions for reporting messages to the user.
#

sub error
{
	my $indent = (shift @_) + 0;
	my $message = shift @_;
	print "ERROR " . ("    " x $indent) . "$message\n";
}

sub info
{
	my $indent = (shift @_) + 0;
	my $message = shift @_;
	print " INFO " . ("    " x $indent) . "$message\n";
}
